#!/usr/bin/env bash
set -euo pipefail

REQUIRED_CONTEXT_FILES=(
    "product.md"
    "product-guidelines.md"
    "workflow.md"
    "tech-stack.md"
)

ACTIVE_TRACK_FILE="conductor/.active_track"
DEFAULT_GOVERNANCE_DIR="outputs/governance"

usage() {
    echo "Usage: multipowers {init|doctor|update|track|route|run|workflow}" >&2
    echo "" >&2
    echo "Commands:" >&2
    echo "  init      Initialize multipowers in current project" >&2
    echo "  doctor    Check installation and dependencies" >&2
    echo "  update    Check/apply safe updates" >&2
    echo "  track     Manage development tracks" >&2
    echo "  route     Route a task to fast/standard lane" >&2
    echo "  run       Route and execute in one command" >&2
    echo "  workflow  Execute workflow-driven standard lane" >&2
}

track_usage() {
    echo "Usage: multipowers track {new|list|start|complete|status}" >&2
    echo "" >&2
    echo "Commands:" >&2
    echo "  new       Create a new track" >&2
    echo "  list      List all tracks" >&2
    echo "  start     Start working on a track" >&2
    echo "  complete  Mark a track as completed" >&2
    echo "  status    Show track status" >&2
}

workflow_usage() {
    echo "Usage:" >&2
    echo "  multipowers workflow run <workflow-name> --task <text> [--request-id <id>] [--track-id <id>] [--allow-untracked] [--dry-run] [--json]" >&2
    echo "  multipowers workflow list [--json]" >&2
    echo "  multipowers workflow validate" >&2
}

resolve_roles_config() {
    if [ -f "conductor/config/roles.json" ]; then
        echo "conductor/config/roles.json"
    else
        echo "config/roles.default.json"
    fi
}

resolve_mcp_config() {
    if [ -f "conductor/config/mcp.json" ]; then
        echo "conductor/config/mcp.json"
    else
        echo "config/mcp.default.json"
    fi
}

resolve_workflow_config() {
    if [ -f "conductor/config/workflows.json" ]; then
        echo "conductor/config/workflows.json"
    else
        echo "config/workflows.default.json"
    fi
}

resolve_context_mode() {
    local mode=${MULTIPOWERS_CONTEXT_MODE:-strict}
    if [ "$mode" != "strict" ] && [ "$mode" != "lenient" ]; then
        echo "strict"
        return
    fi
    echo "$mode"
}

print_context_checklist() {
    echo "Context checklist:" >&2
    local file
    for file in "${REQUIRED_CONTEXT_FILES[@]}"; do
        echo "  - conductor/context/${file}" >&2
    done
}

generate_request_id() {
    echo "req-$(date +%s)-$RANDOM"
}

emit_runtime_event() {
    local event=$1
    local role=${2:-router}
    local request_id=${3:-}
    local track_id=${4:-}
    local lane=${5:-}
    local workflow=${6:-}
    local node=${7:-}
    local reason=${8:-}
    local metadata_json=${9:-}

    if [ ! -f "connectors/utils.py" ] || ! command -v python3 >/dev/null 2>&1; then
        return 0
    fi

    local cmd=(python3 connectors/utils.py event-log --event "$event" --role "$role")
    [ -n "$request_id" ] && cmd+=(--request-id "$request_id")
    [ -n "$track_id" ] && cmd+=(--track-id "$track_id")
    [ -n "$lane" ] && cmd+=(--lane "$lane")
    [ -n "$workflow" ] && cmd+=(--workflow "$workflow")
    [ -n "$node" ] && cmd+=(--node "$node")
    [ -n "$reason" ] && cmd+=(--reason "$reason")
    [ -n "$metadata_json" ] && cmd+=(--metadata-json "$metadata_json")

    "${cmd[@]}" >/dev/null 2>&1 || true
}

track_id_from_file() {
    local track_file=$1
    basename "$track_file" .md
}

set_active_track() {
    local track_id=$1
    mkdir -p conductor
    printf '%s\n' "$track_id" > "$ACTIVE_TRACK_FILE"
}

get_active_track() {
    if [ ! -f "$ACTIVE_TRACK_FILE" ]; then
        return 0
    fi

    local value
    value=$(sed -n '1p' "$ACTIVE_TRACK_FILE" | tr -d '[:space:]')
    if [ -n "$value" ]; then
        echo "$value"
    fi
}

clear_active_track_if_match() {
    local track_id=$1
    local active_track
    active_track=$(get_active_track)
    if [ -n "$active_track" ] && [ "$active_track" = "$track_id" ]; then
        rm -f "$ACTIVE_TRACK_FILE"
    fi
}

resolve_execution_track_id() {
    local provided_track_id=$1
    local allow_untracked=$2

    if [ -n "$provided_track_id" ]; then
        echo "$provided_track_id"
        return 0
    fi

    local active_track
    active_track=$(get_active_track)
    if [ -n "$active_track" ]; then
        echo "$active_track"
        return 0
    fi

    if [ "$allow_untracked" = "true" ]; then
        echo ""
        return 0
    fi

    echo "Error: No active track context found. Run './bin/multipowers track start <track-name>' first, or use --allow-untracked for explicit bypass." >&2
    return 1
}

upsert_track_metadata_line() {
    local track_file=$1
    local key=$2
    local value=$3

    if grep -q "^\*\*$key:\*\*" "$track_file"; then
        sed -i "s|^\*\*$key:\*\* .*|**$key:** $value|" "$track_file"
    else
        printf "**%s:** %s\n" "$key" "$value" >> "$track_file"
    fi
}

default_governance_artifact_path() {
    local track_id=$1
    mkdir -p "$DEFAULT_GOVERNANCE_DIR"
    local suffix="global"
    if [ -n "$track_id" ]; then
        suffix="$track_id"
    fi
    echo "$DEFAULT_GOVERNANCE_DIR/$(date +%Y%m%d)-${suffix}.json"
}


check_context_health() {
    local mode
    mode=$(resolve_context_mode)
    local fail=0
    local context_dir="conductor/context"

    echo "  [INFO] context mode: $mode"

    if [ ! -d "$context_dir" ]; then
        if [ "$mode" = "strict" ]; then
            echo "  [FAIL] context directory missing: $context_dir"
            echo "  [INFO] Fix: ./bin/multipowers init --repair"
            return 1
        fi
        echo "  [WARN] context directory missing: $context_dir"
        echo "  [INFO] Fix: ./bin/multipowers init --repair"
        return 0
    fi

    shopt -s nullglob
    local context_files=("$context_dir"/*.md)
    shopt -u nullglob
    echo "  [INFO] context markdown files: ${#context_files[@]}"

    local -a missing=()
    local file
    for file in "${REQUIRED_CONTEXT_FILES[@]}"; do
        if [ -f "$context_dir/$file" ]; then
            echo "  [PASS] context file exists: $context_dir/$file"
        else
            missing+=("$file")
            if [ "$mode" = "strict" ]; then
                echo "  [FAIL] context file missing: $context_dir/$file"
                fail=1
            else
                echo "  [WARN] context file missing: $context_dir/$file"
            fi
        fi
    done

    if [ ${#missing[@]} -gt 0 ]; then
        echo "  [INFO] Missing context files: ${missing[*]}"
        echo "  [INFO] Fix: ./bin/multipowers init --repair"
    fi

    return "$fail"
}

run_context_quality_check() {
    local mode
    mode=$(resolve_context_mode)

    if [ ! -f "scripts/check_context_quality.py" ] || ! command -v python3 >/dev/null 2>&1; then
        echo "  [WARN] context quality validator unavailable (scripts/check_context_quality.py)"
        return 0
    fi

    if [ ! -d "conductor/context" ]; then
        return 0
    fi

    if python3 scripts/check_context_quality.py --context-dir conductor/context --quiet >/dev/null 2>&1; then
        echo "  [PASS] context quality checks passed"
        return 0
    fi

    if [ "$mode" = "strict" ]; then
        echo "  [FAIL] context quality checks failed"
        echo "  [INFO] Fix: fill context files and remove placeholders/TODO"
        return 1
    fi

    echo "  [WARN] context quality checks failed"
    echo "  [INFO] Fix: fill context files and remove placeholders/TODO"
    return 0
}

refresh_track_metadata() {
    local track_file=$1
    local new_status=$2
    local owner=$3
    local today
    today=$(date +%Y-%m-%d)

    if grep -q '^\*\*Status:\*\*' "$track_file"; then
        sed -i "s|^\*\*Status:\*\* .*|**Status:** $new_status|" "$track_file"
    else
        printf "\n**Status:** %s\n" "$new_status" >> "$track_file"
    fi

    if grep -q '^\*\*Updated At:\*\*' "$track_file"; then
        sed -i "s|^\*\*Updated At:\*\* .*|**Updated At:** $today|" "$track_file"
    else
        printf "**Updated At:** %s\n" "$today" >> "$track_file"
    fi

    if grep -q '^\*\*Owner:\*\*' "$track_file"; then
        sed -i "s|^\*\*Owner:\*\* .*|**Owner:** $owner|" "$track_file"
    else
        printf "**Owner:** %s\n" "$owner" >> "$track_file"
    fi
}

extract_track_status() {
    local track_file=$1
    sed -n 's/^\*\*Status:\*\*[[:space:]]*//p' "$track_file" | head -1
}

find_track_file() {
    local needle=$1
    local -a matches=()

    if [ -f "conductor/tracks/${needle}" ]; then
        echo "conductor/tracks/${needle}"
        return 0
    fi

    if [ -f "conductor/tracks/${needle}.md" ]; then
        echo "conductor/tracks/${needle}.md"
        return 0
    fi

    shopt -s nullglob
    local candidate
    for candidate in conductor/tracks/track-*-${needle}.md; do
        matches+=("$candidate")
    done

    if [ ${#matches[@]} -eq 0 ]; then
        for candidate in conductor/tracks/*${needle}*.md; do
            matches+=("$candidate")
        done
    fi
    shopt -u nullglob

    if [ ${#matches[@]} -eq 0 ]; then
        return 1
    fi

    if [ ${#matches[@]} -gt 1 ]; then
        echo "[MULTIPOWERS ERROR] Multiple tracks matched '${needle}':" >&2
        local item
        for item in "${matches[@]}"; do
            echo "  - ${item}" >&2
        done
        return 2
    fi

    echo "${matches[0]}"
}

resolve_track_for_action() {
    local needle=$1

    local track_file
    local rc=0
    track_file=$(find_track_file "$needle") || rc=$?

    if [ "$rc" -eq 0 ]; then
        echo "$track_file"
        return 0
    fi

    if [ "$rc" -eq 2 ]; then
        echo "Error: Track name '${needle}' is ambiguous. Use full filename or a more specific name." >&2
    else
        echo "Error: Track not found: $needle" >&2
    fi
    return 1
}

slugify_feature_name() {
    local raw_name=$1
    local normalized
    normalized=$(printf '%s' "$raw_name" | tr '[:upper:]' '[:lower:]' | tr '[:space:]' '-' | tr -cd 'a-z0-9-_')
    normalized=$(printf '%s' "$normalized" | sed 's/-\{2,\}/-/g; s/^-//; s/-$//')

    if [ -z "$normalized" ]; then
        local checksum
        checksum=$(printf '%s' "$raw_name" | cksum | awk '{print $1}')
        normalized="task-${checksum:0:8}"
    fi

    echo "$normalized"
}

ensure_conductor_base() {
    mkdir -p conductor
    mkdir -p conductor/config conductor/context conductor/tracks
}

repair_conductor() {
    ensure_conductor_base

    local added=0

    if [ ! -f "conductor/config/roles.json" ]; then
        cp templates/conductor/config/roles.json conductor/config/roles.json
        echo "  [ADD] conductor/config/roles.json"
        added=$((added + 1))
    fi

    shopt -s nullglob
    local template_context
    for template_context in templates/conductor/context/*.md; do
        local filename
        filename=$(basename "$template_context")
        local target="conductor/context/${filename}"
        if [ ! -f "$target" ]; then
            cp "$template_context" "$target"
            echo "  [ADD] $target"
            added=$((added + 1))
        fi
    done
    shopt -u nullglob

    echo "✓ Conductor repair completed (${added} file(s) added)"
    print_context_checklist
}

route_command() {
    local task=""
    local risk_hint=""
    local force_lane=""
    local json_mode="false"
    local request_id=""
    local track_id=""

    while [ $# -gt 0 ]; do
        case "$1" in
            --task)
                task=${2:-}
                shift 2
                ;;
            --risk-hint)
                risk_hint=${2:-}
                shift 2
                ;;
            --force-lane)
                force_lane=${2:-}
                shift 2
                ;;
            --json)
                json_mode="true"
                shift
                ;;
            --request-id)
                request_id=${2:-}
                shift 2
                ;;
            --track-id)
                track_id=${2:-}
                shift 2
                ;;
            *)
                echo "Error: Unknown route option: $1" >&2
                echo "Usage: multipowers route --task <text> [--risk-hint low|medium|high|critical] [--force-lane fast|standard] [--json]" >&2
                return 1
                ;;
        esac
    done

    if [ -z "$task" ]; then
        echo "Error: route requires --task" >&2
        return 1
    fi

    if [ -z "$request_id" ]; then
        request_id=$(generate_request_id)
    fi

    if [ ! -f "scripts/route_task.py" ]; then
        echo "Error: routing script not found: scripts/route_task.py" >&2
        return 1
    fi

    local route_args=(--task "$task" --json)
    [ -n "$risk_hint" ] && route_args+=(--risk-hint "$risk_hint")
    [ -n "$force_lane" ] && route_args+=(--force-lane "$force_lane")

    local route_json
    if ! route_json=$(python3 scripts/route_task.py "${route_args[@]}"); then
        return 1
    fi

    local parsed
    parsed=$(python3 - "$route_json" <<'PY'
import json
import sys

payload = json.loads(sys.argv[1])
fields = [
    payload.get("lane", ""),
    payload.get("reason", ""),
    payload.get("suggested_workflow", ""),
    payload.get("suggested_role", ""),
    json.dumps(
        {
            "suggested_workflow": payload.get("suggested_workflow", ""),
            "suggested_role": payload.get("suggested_role", ""),
            "task": payload.get("task", ""),
        },
        ensure_ascii=False,
        sort_keys=True,
    ),
]
print("\t".join(fields))
PY
)

    local lane reason suggested_workflow suggested_role metadata_json
    IFS=$'\t' read -r lane reason suggested_workflow suggested_role metadata_json <<< "$parsed"

    emit_runtime_event "lane_selected" "router" "$request_id" "$track_id" "$lane" "$suggested_workflow" "" "$reason" "$metadata_json"

    if [ "$json_mode" = "true" ]; then
        python3 - "$route_json" "$request_id" "$track_id" <<'PY'
import json
import sys

payload = json.loads(sys.argv[1])
payload["request_id"] = sys.argv[2]
if sys.argv[3]:
    payload["track_id"] = sys.argv[3]
print(json.dumps(payload, ensure_ascii=False, sort_keys=True))
PY
        return 0
    fi

    echo "request_id=$request_id"
    [ -n "$track_id" ] && echo "track_id=$track_id"
    echo "lane=$lane"
    echo "reason=$reason"
    echo "suggested_workflow=$suggested_workflow"
    echo "suggested_role=$suggested_role"
}

run_command() {
    local task=""
    local risk_hint=""
    local force_lane=""
    local json_mode="false"
    local request_id=""
    local track_id=""
    local allow_untracked="false"

    while [ $# -gt 0 ]; do
        case "$1" in
            --task)
                task=${2:-}
                shift 2
                ;;
            --risk-hint)
                risk_hint=${2:-}
                shift 2
                ;;
            --force-lane)
                force_lane=${2:-}
                shift 2
                ;;
            --json)
                json_mode="true"
                shift
                ;;
            --request-id)
                request_id=${2:-}
                shift 2
                ;;
            --track-id)
                track_id=${2:-}
                shift 2
                ;;
            --allow-untracked)
                allow_untracked="true"
                shift
                ;;
            *)
                echo "Error: Unknown run option: $1" >&2
                echo "Usage: multipowers run --task <text> [--risk-hint low|medium|high|critical] [--force-lane fast|standard] [--request-id <id>] [--track-id <id>] [--allow-untracked] [--json]" >&2
                return 1
                ;;
        esac
    done

    if [ -z "$task" ]; then
        echo "Error: run requires --task" >&2
        return 1
    fi

    if [ -z "$request_id" ]; then
        request_id=$(generate_request_id)
    fi

    local resolved_track_id
    if ! resolved_track_id=$(resolve_execution_track_id "$track_id" "$allow_untracked"); then
        return 1
    fi
    track_id="$resolved_track_id"

    local route_args=(--task "$task" --json --request-id "$request_id")
    [ -n "$risk_hint" ] && route_args+=(--risk-hint "$risk_hint")
    [ -n "$force_lane" ] && route_args+=(--force-lane "$force_lane")
    [ -n "$track_id" ] && route_args+=(--track-id "$track_id")

    local route_json
    if ! route_json=$(route_command "${route_args[@]}"); then
        return 1
    fi

    local parsed
    parsed=$(python3 - "$route_json" <<'PY'
import json
import sys
payload = json.loads(sys.argv[1])
print("\t".join([
    payload.get("lane", ""),
    payload.get("suggested_workflow", ""),
    payload.get("suggested_role", ""),
    payload.get("reason", ""),
]))
PY
)

    local lane suggested_workflow suggested_role reason
    IFS=$'\t' read -r lane suggested_workflow suggested_role reason <<< "$parsed"

    if [ "$lane" = "standard" ]; then
        local workflow_name=${suggested_workflow:-subagent-driven-development}
        local workflow_args=(run "$workflow_name" --task "$task" --request-id "$request_id" --json)
        [ -n "$track_id" ] && workflow_args+=(--track-id "$track_id")
        [ "$allow_untracked" = "true" ] && workflow_args+=(--allow-untracked)

        local workflow_output
        set +e
        workflow_output=$(workflow_command "${workflow_args[@]}" 2>&1)
        local rc=$?
        set -e

        if [ "$rc" -ne 0 ]; then
            if [ "$json_mode" = "true" ]; then
                python3 - "$route_json" "$request_id" "$track_id" "$workflow_output" "$rc" <<'PY'
import json
import sys
payload = json.loads(sys.argv[1])
out = {
    "request_id": sys.argv[2],
    "lane": payload.get("lane"),
    "reason": payload.get("reason"),
    "suggested_workflow": payload.get("suggested_workflow"),
    "suggested_role": payload.get("suggested_role"),
    "execution": {
        "status": "failed",
        "mode": "workflow",
        "exit_code": int(sys.argv[5]),
        "stderr": sys.argv[4].strip(),
    },
}
if sys.argv[3]:
    out["track_id"] = sys.argv[3]
print(json.dumps(out, ensure_ascii=False, sort_keys=True))
PY
            else
                echo "$workflow_output" >&2
            fi
            return "$rc"
        fi

        if [ "$json_mode" = "true" ]; then
            python3 - "$route_json" "$workflow_output" "$request_id" "$track_id" <<'PY'
import json
import sys

route_payload = json.loads(sys.argv[1])
workflow_raw = sys.argv[2]
try:
    workflow_payload = json.loads(workflow_raw)
except json.JSONDecodeError:
    workflow_payload = {"raw_output": workflow_raw}

out = {
    "request_id": sys.argv[3],
    "lane": route_payload.get("lane"),
    "reason": route_payload.get("reason"),
    "suggested_workflow": route_payload.get("suggested_workflow"),
    "suggested_role": route_payload.get("suggested_role"),
    "execution": {
        "status": "ok",
        "mode": "workflow",
        "workflow_output": workflow_payload,
    },
}
if sys.argv[4]:
    out["track_id"] = sys.argv[4]
print(json.dumps(out, ensure_ascii=False, sort_keys=True))
PY
        else
            echo "$workflow_output"
        fi

        return 0
    fi

    local role=${suggested_role:-coder}
    emit_runtime_event "fast_lane_dispatched" "$role" "$request_id" "$track_id" "fast" "" "" "fast lane dispatch started"

    local fast_output
    set +e
    fast_output=$(MULTIPOWERS_REQUEST_ID="$request_id" ./bin/ask-role "$role" "$task" 2>&1)
    local rc=$?
    set -e

    emit_runtime_event "fast_lane_finished" "$role" "$request_id" "$track_id" "fast" "" "" "fast lane dispatch completed" "{\"exit_code\":$rc}"

    if [ "$rc" -ne 0 ]; then
        if [ "$json_mode" = "true" ]; then
            python3 - "$route_json" "$request_id" "$track_id" "$fast_output" "$rc" "$role" <<'PY'
import json
import sys
payload = json.loads(sys.argv[1])
out = {
    "request_id": sys.argv[2],
    "lane": payload.get("lane"),
    "reason": payload.get("reason"),
    "suggested_workflow": payload.get("suggested_workflow"),
    "suggested_role": payload.get("suggested_role"),
    "execution": {
        "status": "failed",
        "mode": "fast",
        "role": sys.argv[6],
        "exit_code": int(sys.argv[5]),
        "stderr": sys.argv[4].strip(),
    },
}
if sys.argv[3]:
    out["track_id"] = sys.argv[3]
print(json.dumps(out, ensure_ascii=False, sort_keys=True))
PY
        else
            echo "$fast_output" >&2
        fi
        return "$rc"
    fi

    if [ "$json_mode" = "true" ]; then
        python3 - "$route_json" "$request_id" "$track_id" "$fast_output" "$role" <<'PY'
import json
import sys
payload = json.loads(sys.argv[1])
out = {
    "request_id": sys.argv[2],
    "lane": payload.get("lane"),
    "reason": payload.get("reason"),
    "suggested_workflow": payload.get("suggested_workflow"),
    "suggested_role": payload.get("suggested_role"),
    "execution": {
        "status": "ok",
        "mode": "fast",
        "role": sys.argv[5],
        "stdout": sys.argv[4].strip(),
    },
}
if sys.argv[3]:
    out["track_id"] = sys.argv[3]
print(json.dumps(out, ensure_ascii=False, sort_keys=True))
PY
        return 0
    fi

    echo "$fast_output"
}

workflow_command() {
    local action=${1:-}
    shift || true

    case "$action" in
        run)
            local workflow_name=${1:-}
            if [ -z "$workflow_name" ]; then
                workflow_usage
                return 1
            fi
            shift

            local task=""
            local json_mode="false"
            local dry_run="false"
            local request_id=""
            local track_id=""
            local allow_untracked="false"

            while [ $# -gt 0 ]; do
                case "$1" in
                    --task)
                        task=${2:-}
                        shift 2
                        ;;
                    --json)
                        json_mode="true"
                        shift
                        ;;
                    --dry-run)
                        dry_run="true"
                        shift
                        ;;
                    --request-id)
                        request_id=${2:-}
                        shift 2
                        ;;
                    --track-id)
                        track_id=${2:-}
                        shift 2
                        ;;
                    --allow-untracked)
                        allow_untracked="true"
                        shift
                        ;;
                    *)
                        echo "Error: Unknown workflow option: $1" >&2
                        workflow_usage
                        return 1
                        ;;
                esac
            done

            if [ -z "$task" ]; then
                echo "Error: workflow run requires --task" >&2
                workflow_usage
                return 1
            fi

            if [ -z "$request_id" ]; then
                request_id=$(generate_request_id)
            fi

            local resolved_track_id
            if ! resolved_track_id=$(resolve_execution_track_id "$track_id" "$allow_untracked"); then
                return 1
            fi
            track_id="$resolved_track_id"

            local config_path
            config_path=$(resolve_workflow_config)
            if [ ! -f "$config_path" ]; then
                echo "Error: workflow config not found: $config_path" >&2
                echo "Hint: add conductor/config/workflows.json or keep config/workflows.default.json" >&2
                return 1
            fi

            if [ ! -f "scripts/execute_workflow.py" ]; then
                echo "Error: workflow executor missing: scripts/execute_workflow.py" >&2
                return 1
            fi

            local roles_config
            roles_config=$(resolve_roles_config)

            emit_runtime_event "workflow_started" "router" "$request_id" "$track_id" "standard" "$workflow_name" "" "workflow execution started"

            local cmd=(
                python3 scripts/execute_workflow.py
                --config "$config_path"
                --workflow "$workflow_name"
                --task "$task"
                --ask-role "./bin/ask-role"
                --roles-config "$roles_config"
                --request-id "$request_id"
            )

            [ -n "$track_id" ] && cmd+=(--track-id "$track_id")
            [ "$dry_run" = "true" ] && cmd+=(--dry-run)
            [ "$json_mode" = "true" ] && cmd+=(--json)

            local output
            set +e
            if [ "$json_mode" = "true" ]; then
                output=$("${cmd[@]}" 2>&1)
                rc=$?
            else
                "${cmd[@]}"
                rc=$?
            fi
            set -e

            if [ "$rc" -ne 0 ]; then
                emit_runtime_event "workflow_finished" "router" "$request_id" "$track_id" "standard" "$workflow_name" "" "workflow execution failed" "{\"exit_code\":$rc}"
                if [ "$json_mode" = "true" ]; then
                    echo "$output" >&2
                fi
                return "$rc"
            fi

            emit_runtime_event "workflow_finished" "router" "$request_id" "$track_id" "standard" "$workflow_name" "" "workflow execution completed"

            if [ "$json_mode" = "true" ]; then
                echo "$output"
            fi
            ;;

        list)
            local json_mode="false"
            while [ $# -gt 0 ]; do
                case "$1" in
                    --json)
                        json_mode="true"
                        shift
                        ;;
                    *)
                        echo "Error: Unknown workflow list option: $1" >&2
                        workflow_usage
                        return 1
                        ;;
                esac
            done

            local config_path
            config_path=$(resolve_workflow_config)
            if [ ! -f "$config_path" ]; then
                echo "Error: workflow config not found: $config_path" >&2
                return 1
            fi

            if [ "$json_mode" = "true" ]; then
                python3 - "$config_path" <<'PY'
import json
import sys

with open(sys.argv[1], 'r', encoding='utf-8') as handle:
    config = json.load(handle)

workflows = config.get('workflows', {})
if not isinstance(workflows, dict):
    print(json.dumps({'workflows': []}, ensure_ascii=False, sort_keys=True))
    raise SystemExit(0)

payload = {'workflows': sorted(workflows.keys())}
print(json.dumps(payload, ensure_ascii=False, sort_keys=True))
PY
                return 0
            fi

            echo "Workflows:"
            if ! python3 - "$config_path" <<'PY'
import json
import sys

with open(sys.argv[1], 'r', encoding='utf-8') as handle:
    config = json.load(handle)

workflows = config.get('workflows', {})
if not isinstance(workflows, dict):
    raise SystemExit(1)

for name in sorted(workflows.keys()):
    print(name)
PY
            then
                echo "Error: invalid workflow config structure in $config_path" >&2
                return 1
            fi
            ;;

        validate)
            if [ $# -gt 0 ]; then
                echo "Error: workflow validate does not accept extra arguments" >&2
                workflow_usage
                return 1
            fi

            local config_path
            config_path=$(resolve_workflow_config)
            if [ ! -f "$config_path" ]; then
                echo "Error: workflow config not found: $config_path" >&2
                return 1
            fi

            local roles_config
            roles_config=$(resolve_roles_config)

            if ! python3 - "$config_path" "$roles_config" <<'PY'
import json
import sys

workflow_path = sys.argv[1]
roles_path = sys.argv[2]
with open(workflow_path, 'r', encoding='utf-8') as handle:
    config = json.load(handle)

try:
    with open(roles_path, 'r', encoding='utf-8') as handle:
        roles_config = json.load(handle)
except FileNotFoundError:
    roles_config = {}

roles_obj = roles_config.get('roles', {}) if isinstance(roles_config, dict) else {}
available_roles = set(roles_obj.keys())

workflows = config.get('workflows')
if not isinstance(workflows, dict) or not workflows:
    raise SystemExit('[WORKFLOW-VALIDATE] workflows must be a non-empty object')

for name, workflow in workflows.items():
    if not isinstance(workflow, dict):
        raise SystemExit(f'[WORKFLOW-VALIDATE] workflow {name!r} must be an object')

    default_role = workflow.get('default_role')
    if not isinstance(default_role, str) or not default_role.strip():
        raise SystemExit(f'[WORKFLOW-VALIDATE] workflow {name!r} missing default_role')
    if default_role not in available_roles:
        raise SystemExit(f"[WORKFLOW-VALIDATE] workflow {name!r} unknown role: {default_role!r} (node=default_role)")

    nodes = workflow.get('nodes')
    if not isinstance(nodes, list) or not nodes:
        raise SystemExit(f'[WORKFLOW-VALIDATE] workflow {name!r} nodes must be a non-empty array')

    for idx, node in enumerate(nodes, start=1):
        if not isinstance(node, dict):
            raise SystemExit(f'[WORKFLOW-VALIDATE] workflow {name!r} node[{idx}] must be an object')
        node_id = node.get('id')
        if not isinstance(node_id, str) or not node_id.strip():
            raise SystemExit(f'[WORKFLOW-VALIDATE] workflow {name!r} node[{idx}] missing id')
        prompt_template = node.get('prompt_template')
        if not isinstance(prompt_template, str) or not prompt_template.strip():
            raise SystemExit(f'[WORKFLOW-VALIDATE] workflow {name!r} node[{idx}] missing prompt_template')

        role = node.get('role', default_role)
        if not isinstance(role, str) or not role.strip():
            raise SystemExit(f'[WORKFLOW-VALIDATE] workflow {name!r} node[{idx}] has invalid role override')
        if role not in available_roles:
            raise SystemExit(f"[WORKFLOW-VALIDATE] workflow {name!r} unknown role: {role!r} (node={node_id!r})")

print(f'[WORKFLOW-VALIDATE] PASS ({len(workflows)} workflows)')
PY
            then
                return 1
            fi
            ;;

        *)
            workflow_usage
            return 1
            ;;
    esac
}
init_command() {
    local init_mode="default"
    local confirm_force="false"

    local arg
    for arg in "${@:2}"; do
        case "$arg" in
            --repair)
                if [ "$init_mode" = "force" ]; then
                    echo "Error: --repair cannot be combined with --force" >&2
                    exit 1
                fi
                init_mode="repair"
                ;;
            --force)
                if [ "$init_mode" = "repair" ]; then
                    echo "Error: --force cannot be combined with --repair" >&2
                    exit 1
                fi
                init_mode="force"
                ;;
            --yes)
                confirm_force="true"
                ;;
            *)
                echo "Error: Unknown init option: $arg" >&2
                echo "Usage: multipowers init [--repair|--force --yes]" >&2
                exit 1
                ;;
        esac
    done

    case "$init_mode" in
        repair)
            echo "Repairing multipowers conductor files..."
            repair_conductor
            echo "Next: Fill required context files and run ./bin/multipowers doctor"
            ;;

        force)
            if [ "$confirm_force" != "true" ]; then
                echo "Error: --force is destructive and requires --yes confirmation" >&2
                echo "Usage: multipowers init --force --yes" >&2
                exit 1
            fi
            echo "Initializing multipowers in current directory (force mode)..."
            rm -rf ./conductor
            cp -r templates/conductor ./conductor
            echo "✓ Conductor structure recreated"
            print_context_checklist
            echo "Next: Fill required context files and run ./bin/multipowers doctor"
            ;;

        *)
            echo "Initializing multipowers in current directory..."
            if [ -d "./conductor" ]; then
                echo "✓ Conductor structure already exists (use --repair to fill gaps, or --force --yes to recreate)"
                exit 0
            fi
            cp -r templates/conductor ./conductor
            echo "✓ Conductor structure created"
            print_context_checklist
            echo "Next: Fill required context files and run ./bin/multipowers doctor"
            ;;
    esac
}

doctor_command() {
    echo "Checking multipowers installation..."
    local exit_code=0

    if [ -f "bin/ask-role" ]; then
        echo "  [PASS] bin/ask-role exists"
    else
        echo "  [FAIL] bin/ask-role not found"
        exit_code=1
    fi

    if [ -f "config/roles.default.json" ]; then
        echo "  [PASS] config/roles.default.json exists"
    else
        echo "  [FAIL] config/roles.default.json not found"
        exit_code=1
    fi

    if [ -f "connectors/codex.py" ] && [ -f "connectors/gemini.py" ] && [ -f "connectors/claude.py" ]; then
        echo "  [PASS] connectors exist"
    else
        echo "  [FAIL] connectors not found"
        exit_code=1
    fi

    if command -v python3 >/dev/null 2>&1; then
        echo "  [PASS] python3 is installed"
    else
        echo "  [FAIL] python3 is required"
        exit_code=1
    fi

    if command -v jq >/dev/null 2>&1; then
        echo "  [PASS] jq is installed (optional)"
    else
        echo "  [WARN] jq is not installed (optional)"
    fi

    local config_path
    config_path=$(resolve_roles_config)
    if [ -f "$config_path" ]; then
        echo "  [PASS] effective roles config exists"
        echo "  [INFO] effective roles config: $config_path"
    else
        echo "  [FAIL] effective roles config missing: $config_path"
        exit_code=1
    fi

    if [ -f "config/roles.schema.json" ]; then
        echo "  [PASS] roles schema exists"
    else
        echo "  [FAIL] roles schema missing: config/roles.schema.json"
        exit_code=1
    fi

    if [ -f "scripts/validate_roles.py" ] && command -v python3 >/dev/null 2>&1; then
        if python3 scripts/validate_roles.py --config "$config_path" --schema config/roles.schema.json --quiet >/dev/null 2>&1; then
            echo "  [PASS] roles config validates against schema"
        else
            echo "  [FAIL] roles config validation failed"
            exit_code=1
        fi
    else
        echo "  [WARN] schema validator unavailable (scripts/validate_roles.py)"
    fi

    local mcp_config
    mcp_config=$(resolve_mcp_config)
    if [ -f "$mcp_config" ]; then
        echo "  [PASS] effective mcp config exists"
        echo "  [INFO] effective mcp config: $mcp_config"
        if [ -f "scripts/validate_mcp.py" ] && command -v python3 >/dev/null 2>&1; then
            if python3 scripts/validate_mcp.py --config "$mcp_config" --quiet; then
                echo "  [PASS] mcp config validates"
            else
                echo "  [FAIL] mcp config validation failed"
                exit_code=1
            fi
        else
            echo "  [WARN] mcp validator unavailable (scripts/validate_mcp.py)"
        fi
    else
        echo "  [FAIL] effective mcp config missing: $mcp_config"
        exit_code=1
    fi

    local workflow_config
    workflow_config=$(resolve_workflow_config)
    if [ -f "$workflow_config" ]; then
        echo "  [PASS] effective workflow config exists"
        echo "  [INFO] effective workflow config: $workflow_config"
    else
        echo "  [FAIL] effective workflow config missing: $workflow_config"
        exit_code=1
    fi

    if ! check_context_health; then
        exit_code=1
    fi

    if ! run_context_quality_check; then
        exit_code=1
    fi

    if [ -f "scripts/check_template_sync_candidates.py" ] && command -v python3 >/dev/null 2>&1; then
        if python3 scripts/check_template_sync_candidates.py --quiet >/dev/null 2>&1; then
            echo "  [PASS] template sync candidates check"
        else
            echo "  [WARN] template sync candidates drift detected"
        fi
    fi

    return "$exit_code"
}

update_command() {
    local mode="check"
    local json_mode="false"
    local confirm_apply="false"

    while [ $# -gt 0 ]; do
        case "$1" in
            --check)
                mode="check"
                shift
                ;;
            --apply)
                mode="apply"
                shift
                ;;
            --yes)
                confirm_apply="true"
                shift
                ;;
            --json)
                json_mode="true"
                shift
                ;;
            --help|-h)
                echo "Usage: multipowers update [--check|--apply --yes] [--json]"
                return 0
                ;;
            *)
                echo "Error: Unknown update option: $1" >&2
                echo "Usage: multipowers update [--check|--apply --yes] [--json]" >&2
                return 1
                ;;
        esac
    done

    if [ ! -f "scripts/check_update_state.sh" ]; then
        echo "Error: update helper missing: scripts/check_update_state.sh" >&2
        return 1
    fi

    local cmd=(bash scripts/check_update_state.sh)
    [ "$json_mode" = "true" ] && cmd+=(--json)

    if [ "$mode" = "apply" ]; then
        if [ "$confirm_apply" != "true" ]; then
            echo "Error: update --apply requires --yes confirmation" >&2
            return 1
        fi
        cmd+=(--apply)
    fi

    "${cmd[@]}"
}

track_command() {
    local action=${1:-}
    shift || true

    case "$action" in
        new)
            local feature_name=${1:-}
            if [ -z "$feature_name" ]; then
                echo "Usage: multipowers track new <feature-name>" >&2
                return 1
            fi

            local safe_name
            safe_name=$(slugify_feature_name "$feature_name")
            local track_name="track-$(date +%Y%m%d)-${safe_name}"
            local track_file="conductor/tracks/${track_name}.md"

            if [ -f "$track_file" ]; then
                echo "Error: Track already exists: $track_file" >&2
                return 1
            fi

            mkdir -p conductor/tracks
            cp templates/conductor/tracks/example-track.md "$track_file"

            local owner
            owner=$(whoami 2>/dev/null || echo "Unknown")
            local today
            today=$(date +%Y-%m-%d)
            sed -i "s|^# Track: Feature Name|# Track: ${feature_name}|" "$track_file"
            sed -i "s|^\*\*Status:\*\* Proposed|**Status:** Proposed|" "$track_file"
            sed -i "s|^\*\*Updated At:\*\* \[YYYY-MM-DD\]|**Updated At:** ${today}|" "$track_file"
            sed -i "s|^\*\*Owner:\*\* \[Your Name\]|**Owner:** ${owner}|" "$track_file"

            echo "✓ Track created: $track_file"
            echo "Next: Edit the track with goal and requirements"
            ;;

        list)
            if [ ! -d "conductor/tracks" ]; then
                echo "No tracks directory found"
                return 0
            fi

            shopt -s nullglob
            local track_files=(conductor/tracks/*.md)
            shopt -u nullglob

            if [ ${#track_files[@]} -eq 0 ]; then
                echo "No tracks found"
                return 0
            fi

            echo "Tracks:"
            local item
            for item in "${track_files[@]}"; do
                basename "$item"
            done
            ;;

        start)
            local track_name=${1:-}
            if [ -z "$track_name" ]; then
                echo "Usage: multipowers track start <track-name>" >&2
                return 1
            fi

            local track_file
            if ! track_file=$(resolve_track_for_action "$track_name"); then
                return 1
            fi

            local current_status
            current_status=$(extract_track_status "$track_file")
            if [ "$current_status" = "In Progress" ]; then
                local current_id
                current_id=$(track_id_from_file "$track_file")
                set_active_track "$current_id"
                echo "Track is already in progress"
                return 0
            fi
            if [ "$current_status" = "Completed" ]; then
                echo "Error: Cannot restart a completed track" >&2
                return 1
            fi

            local owner
            owner=$(whoami 2>/dev/null || echo "Unknown")
            refresh_track_metadata "$track_file" "In Progress" "$owner"
            set_active_track "$(track_id_from_file "$track_file")"

            echo "✓ Track started: $track_file"
            echo "Status: ${current_status:-Proposed} → In Progress"
            ;;

        complete)
            local track_name=${1:-}
            if [ -z "$track_name" ]; then
                echo "Usage: multipowers track complete <track-name> [--skip-governance] [--governance-mode strict|advisory] [--governance-artifact <path>] [--request-id <id>]" >&2
                return 1
            fi
            shift

            local skip_governance="false"
            local governance_mode="strict"
            local governance_artifact=""
            local request_id=""

            while [ $# -gt 0 ]; do
                case "$1" in
                    --skip-governance)
                        skip_governance="true"
                        shift
                        ;;
                    --governance-mode)
                        governance_mode=${2:-}
                        shift 2
                        ;;
                    --governance-artifact)
                        governance_artifact=${2:-}
                        shift 2
                        ;;
                    --request-id)
                        request_id=${2:-}
                        shift 2
                        ;;
                    *)
                        echo "Error: Unknown track complete option: $1" >&2
                        return 1
                        ;;
                esac
            done

            if [ "$governance_mode" != "strict" ] && [ "$governance_mode" != "advisory" ]; then
                echo "Error: governance mode must be strict or advisory" >&2
                return 1
            fi

            local track_file
            if ! track_file=$(resolve_track_for_action "$track_name"); then
                return 1
            fi

            local current_status
            current_status=$(extract_track_status "$track_file")
            if [ "$current_status" != "In Progress" ]; then
                echo "Error: Can only complete tracks in progress (current: ${current_status:-Unknown})" >&2
                return 1
            fi

            local track_id
            track_id=$(track_id_from_file "$track_file")
            [ -z "$request_id" ] && request_id=$(generate_request_id)

            local governance_status=""
            local artifact_path=""

            if [ "$skip_governance" = "true" ]; then
                governance_status="skipped (explicit bypass)"
                echo "[GOVERNANCE] WARN: bypassed by --skip-governance"
            else
                artifact_path=${governance_artifact:-$(default_governance_artifact_path "$track_id")}
                emit_runtime_event "governance_started" "router" "$request_id" "$track_id" "" "" "" "track completion governance started"

                local gov_cmd=(bash scripts/run_governance_checks.sh --mode "$governance_mode" --artifact "$artifact_path" --request-id "$request_id" --track-id "$track_id")
                set +e
                "${gov_cmd[@]}"
                local gov_rc=$?
                set -e

                if [ "$gov_rc" -ne 0 ]; then
                    emit_runtime_event "governance_finished" "router" "$request_id" "$track_id" "" "" "" "track completion governance failed" "{\"exit_code\":$gov_rc}"
                    echo "Error: governance checks failed; track completion blocked. Use --skip-governance for explicit bypass." >&2
                    return "$gov_rc"
                fi

                governance_status="passed"
                emit_runtime_event "governance_finished" "router" "$request_id" "$track_id" "" "" "" "track completion governance passed" "{\"exit_code\":0}"
            fi

            local owner
            owner=$(whoami 2>/dev/null || echo "Unknown")
            refresh_track_metadata "$track_file" "Completed" "$owner"
            upsert_track_metadata_line "$track_file" "Governance" "$governance_status"
            if [ -n "$artifact_path" ]; then
                upsert_track_metadata_line "$track_file" "Governance Artifact" "$artifact_path"
            fi
            clear_active_track_if_match "$track_id"

            echo "✓ Track completed: $track_file"
            echo "Status: In Progress → Completed"
            ;;

        status)
            local track_name=${1:-}
            if [ -z "$track_name" ]; then
                echo "Usage: multipowers track status <track-name>" >&2
                return 1
            fi

            local track_file
            if ! track_file=$(resolve_track_for_action "$track_name"); then
                return 1
            fi

            grep -E '^(\*\*Status:\*\*|\*\*Updated At:\*\*|\*\*Owner:\*\*|\*\*Governance:\*\*|\*\*Governance Artifact:\*\*)' "$track_file" || echo "No status info found"
            ;;

        *)
            track_usage
            return 1
            ;;
    esac
}

if [ $# -lt 1 ]; then
    usage
    exit 1
fi

SUBCOMMAND=$1
shift || true

case "$SUBCOMMAND" in
    init)
        init_command "$SUBCOMMAND" "$@"
        ;;
    route)
        route_command "$@"
        ;;
    run)
        run_command "$@"
        ;;
    workflow)
        workflow_command "$@"
        ;;
    doctor)
        doctor_command
        ;;
    update)
        update_command "$@"
        ;;
    track)
        track_command "$@"
        ;;
    *)
        usage
        exit 1
        ;;
esac
